function [current_obj,x_pred,err_count,u_vec,alpha,eigen_gap,t_orig_end] = ...
    Nplus2_v3_LP_scalar(label,b_ind,n_sample,cL,u,alpha,sw,...
    dy_LP_test_init,dz_LP_test_init,new_H_LP_test_init,...
    rho)

%% LP settings
options=optimoptions('linprog','Algorithm','interior-point','display','none'); % linear program (LP) setting for Frank-Wolfe algorithm
% options=optimoptions('linprog','Algorithm','interior-point'); % linear program (LP) setting for Frank-Wolfe algorithm
options.OptimalityTolerance=1e-5; % LP optimality tolerance
options.ConstraintTolerance=1e-5; % LP interior-point constraint tolerance

db = 2*label(b_ind); % training labels x 2
dz_plus_idx = db < 0;
dz_minus_idx = db > 0;

dz_ind_plus = b_ind(dz_plus_idx);
dz_ind_minus = b_ind(dz_minus_idx);

%% initialize a psd matrix ABL
% u(n_sample+1)=1e1;
% alpha=1e1;
% % % rng(0);
y0=zeros(n_sample,1);
y0(b_ind)=1;
dy_LP_test_init=[y0;sum(y0)*1e2];
dz_LP_test_init=-(db/2)*1e0;

scalee=1/alpha;
% dy_LP_test_init=dy_LP_test_init*scalee;
% dz_LP_test_init=dz_LP_test_init*scalee;
cL=cL*scalee;
alpha=0;
% scalee=1;

% % % mplus=length(dz_ind_plus);
% % % mminus=length(dz_ind_minus);
% % % alpha=(...
% % %       ((1+(mminus/mplus))*sw-(mminus/mplus))*(dy_LP_test_init(n_sample+1)+sum(dz_LP_test_init))...
% % %       -sum(dz_LP_test_init(dz_ind_minus))+(mminus/mplus)*sum(dz_LP_test_init(dz_ind_plus))...
% % %       )*(mplus/length(b_ind));
  
[initial_H] = construct_H(sw,n_sample,...
    cL,...
    u,...
    alpha,...
    dy_LP_test_init,...
    dz_LP_test_init,...
    dz_ind_plus,...
    dz_ind_minus,...
    3);

% initial_H=initial_H+rho*eye(n_sample+2);

diff_H=norm(vec(new_H_LP_test_init)-vec(initial_H));
disp(['diff H: ' num2str(diff_H)]);
rng(0);
fv_H=randn(n_sample+2,1);

initial_obj=sum(dy_LP_test_init)+db'*dz_LP_test_init;
disp(['v3 LP main iteration ' num2str(0) ' | current obj: ' num2str(initial_obj) ' | mineig: ' num2str(min(eig(initial_H)))]);

t_orig=tic;

tol_set=1e-5;
tol=Inf;
loop_i=0;
while tol>tol_set
    if loop_i==0
        [fv_H,...
            scaled_M,...
            scaled_factors] = ...
            compute_scalars_scalars(...
            initial_H,...
            fv_H,...
            dz_ind_plus,...
            dz_ind_minus,...
            n_sample); % compute scalars
    end
    
    [y,z,current_obj]=LP_core_Nplus2_scalars( ...
        n_sample,...
        scaled_M,...
        scaled_factors,...
        rho,...
        db,...
        options,...
        cL,...
        b_ind,...
        u,...
        alpha,...
        sw,...
        dz_ind_plus,...
        dz_ind_minus);
    
    [updated_H] = construct_H(sw,n_sample,...
        cL,...
        u,...
        alpha,...
        y,...
        z,...
        dz_ind_plus,...
        dz_ind_minus,...
        3);
    
    % %% the solution new_H
    % updated_H=(updated_H+updated_H')/2;
    %
    % %% the original_H converted from new_H
    % original_H=[cL zeros(n_sample,1);zeros(n_sample,1)' 0];
    % % original_H(1:n_sample+1+1:end)=[diag(cL);0]+[y;-sum(z(dz_ind_minus))+0.5*u(n_sample+1)-alpha];
    % original_H(1:n_sample+1+1:end)=[diag(cL);0]+y;
    % % original_H(1:n_sample+1+1:end)=original_H(1:n_sample+1+1:end)+[y(1:n_sample); sum(y(n_sample+1)-sum(z(dz_ind_plus)))]';
    % original_H(b_ind,n_sample+1)=z;
    % original_H(n_sample+1,b_ind)=z;
    %
    % original_H=(original_H+original_H')/2;
    %
    % rng(0);
    % fv_Ho_0=randn(n_sample+1,1);
    % [alpha] = compute_alpha(...
    %     n_sample,...
    %     db,...
    %     b_ind,...
    %     original_H,...
    %     fv_Ho_0);
    
    [fv_H,...
        scaled_M,...
        scaled_factors] = ...
        compute_scalars_scalars(...
        updated_H,...
        fv_H,...
        dz_ind_plus,...
        dz_ind_minus,...
        n_sample); % compute scalars
    
    disp(['v3 LP obj ' num2str(current_obj)]);
    tol=norm(current_obj-initial_obj);
    initial_obj=current_obj;
    loop_i=loop_i+1;
    
end

t_orig_end=toc(t_orig);

%% the solution new_H
updated_H=(updated_H+updated_H')/2;

%% the original_H converted from new_H
original_H=[cL zeros(n_sample,1);zeros(n_sample,1)' 0];
% original_H(1:n_sample+1+1:end)=[diag(cL);0]+[y;-sum(z(dz_ind_minus))+0.5*u(n_sample+1)-alpha];
original_H(1:n_sample+1+1:end)=[diag(cL);0]+y;
% original_H(1:n_sample+1+1:end)=original_H(1:n_sample+1+1:end)+[y(1:n_sample); sum(y(n_sample+1)-sum(z(dz_ind_plus)))]';
original_H(b_ind,n_sample+1)=z;
original_H(n_sample+1,b_ind)=z;

original_H=(original_H+original_H')/2;

H_offdia=original_H;
H_offdia(1:n_sample+1+1:end)=0;

u_vec=diag(original_H)+sum(H_offdia,2);

%% eigen-gap
eigen_gap=min(eig(updated_H))-min(eig(original_H));

% test_v=-1e4-200;
% rr=zeros(100,2);
% for ii=1:100
%     test_v=test_v+200;
%     original_H(end,end)=test_v;
%% first eigenvector of the converted original_H
rng(0);
fv_H_0=randn(n_sample+1,1);

[fv_H,~] = ...
    lobpcg_fv(...
    fv_H_0,...
    original_H*1/scalee,...
    1e-16,...
    1e3);

% [v,~]=eig(original_H*1/scalee);
% fv_H=v(:,1);

[alpha] = compute_alpha(...
    n_sample,...
    db,...
    b_ind,...
    original_H,...
    fv_H);

x_val = sign(label(b_ind(1))*sign(fv_H(1)))*sign(fv_H(1:n_sample));
% x_val = sign(fv_H(1:n_sample));
x_pred=sign(x_val);
err_count = sum(abs(sign(x_val) - label))/2;
disp(['cond H: ' num2str(cond(original_H)) ' | cond H bar: ' num2str(cond(updated_H))]);
% rr(ii,1)=test_v;
% rr(ii,2)=err_count;
%
% end
%
% figure();plot(rr(:,1),rr(:,2));
end